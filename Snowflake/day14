/*  Advanced Joins, Subqueries & CTEs in Snowflake  */

select * from employees;

select * from departments;

-- ðŸ§   Quick Recap â€” What is a JOIN?
-- A JOIN combines rows from two or more tables based on a related column (usually a key).

--ðŸ”¹ INNER JOIN
-- âœ… Returns only matching rows between both tables.

select 
    e.emp_name, e.dept, d.manager
from employees e
inner join departments d
on e.dept = d.dept;

-- ðŸ”¹  LEFT JOIN
-- âœ… Returns all rows from the left table, plus matching rows from the right.

SELECT e.emp_name, e.dept, d.manager
FROM employees e
LEFT JOIN departments d
  ON e.dept = d.dept;

-- ðŸ”¹  RIGHT JOIN
-- âœ… Returns all rows from the right table, plus matching ones from the left.

SELECT e.emp_name, e.dept, d.manager
FROM employees e
RIGHT JOIN departments d
  ON e.dept = d.dept;

-- ðŸ”¹  FULL OUTER JOIN
-- âœ… Combines all records from both sides, showing NULLs where thereâ€™s no match.

SELECT e.emp_name, e.dept AS emp_dept, d.dept AS dept_name, d.manager
FROM employees e
FULL OUTER JOIN departments d
  ON e.dept = d.dept;

-- ðŸ”¹  CROSS JOIN
-- âœ… Cartesian product â€” every combination of both tables.

SELECT e.emp_name, d.dept
FROM employees e
CROSS JOIN departments d;


-- ðŸ”¹ SELF JOIN
-- âœ… Join a table to itself â€” useful for hierarchical data (e.g., manager-employee relationships).

CREATE OR REPLACE TABLE emp_hierarchy (
  emp_id INT,
  emp_name STRING,
  manager_id INT
);

INSERT INTO emp_hierarchy VALUES
(1, 'John', NULL),
(2, 'Alice', 1),
(3, 'Bob', 1),
(4, 'Eva', 2),
(5, 'Raj', 3);

SELECT e.emp_name AS employee,
       m.emp_name AS manager
FROM emp_hierarchy e
LEFT JOIN emp_hierarchy m
  ON e.manager_id = m.emp_id;

-- ðŸ§©  Subqueries (Nested Queries)

SELECT emp_name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

SELECT dept, MAX(avg_salary) AS top_avg
FROM (
  SELECT dept, AVG(salary) AS avg_salary
  FROM employees
  GROUP BY dept
) sub
GROUP BY dept;

-- ðŸ§© Common Table Expressions (CTEs)
-- âœ… CTEs (WITH) make queries readable and reusable.

-- Average Salary by Department
WITH avg_sal AS (
  SELECT dept, AVG(salary) AS avg_salary
  FROM employees
  GROUP BY dept
) 
SELECT e.emp_name, e.dept, e.salary, a.avg_salary
FROM employees e
JOIN avg_sal a ON e.dept = a.dept
WHERE e.salary > a.avg_salary;

-- Multi-CTE Query
WITH dept_count AS (
  SELECT dept, COUNT(*) AS emp_count
  FROM employees
  GROUP BY dept
),
high_salary AS (
  SELECT emp_name, dept, salary
  FROM employees
  WHERE salary > 80000
)
SELECT h.emp_name, h.dept, h.salary, d.emp_count
FROM high_salary h
JOIN dept_count d
  ON h.dept = d.dept;

/* ðŸ§© Analytical Use Cases (Real-World Examples) */

-- ðŸ§  Find the Top 2 Highest-Paid Employees per Department
SELECT *
FROM (
  SELECT emp_name, dept, salary,
         ROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary DESC) AS rank
  FROM employees
)
WHERE rank <= 2;

-- ðŸ§  Find Employees Not Assigned to Any Department
SELECT emp_name
FROM employees
WHERE dept NOT IN (SELECT dept FROM departments) or dept IS NULL;

-- ðŸ§  Department-Wise Salary Comparison
WITH dept_avg AS (
  SELECT dept, AVG(salary) AS avg_sal
  FROM employees
  GROUP BY dept
)
SELECT e.emp_name, e.dept, e.salary, d.avg_sal,
       CASE WHEN e.salary > d.avg_sal THEN 'Above Avg' ELSE 'Below Avg' END AS salary_level
FROM employees e
JOIN dept_avg d ON e.dept = d.dept;



/* ðŸ§  Challenge â€” Practice Problems */

-- List employees who earn the highest salary in each department.

select * from (
SELECT emp_name, dept, salary,
         ROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary DESC) AS rank
FROM employees)
where rank =1;

-- Find departments that have no employees assigned.
SELECT dept, manager
FROM departments
WHERE dept NOT IN (SELECT DISTINCT dept FROM employees WHERE dept IS NOT NULL);


-- Find employees who earn more than the average of all IT department employees.

select 
    emp_name, dept, salary, 
    --avg(salary) over(partition by dept order by salary) avg_salary
from employees
where salary > (select avg(salary) from employees where dept = 'IT');


-- Using a CTE, calculate each departmentâ€™s total salary and list only those above 150,000.

WITH dept_salary AS (
  SELECT dept, SUM(salary) AS total_salary
  FROM employees
  GROUP BY dept
)
SELECT *
FROM dept_salary
WHERE total_salary > 150000;


with cte  as (
select 
   dept,sum(salary) over(partition by dept) dept_sum
from employees
)
select * from cte 
where dept_sum > 150000;

-- Join employees and departments to show: employee name, department name, manager name.

select 
    e.emp_name, d.dept, d.manager
from employees e
left join departments d
on e.dept = d.dept;

--ðŸ’¡ Key Takeaways
| Concept      | Keyword             | Description               |
| ------------ | ------------------- | ------------------------- |
| `INNER JOIN` | Matches both sides  | Only common data          |
| `LEFT JOIN`  | Keep all from left  | Missing right side â†’ NULL |
| `RIGHT JOIN` | Keep all from right | Missing left side â†’ NULL  |
| `FULL JOIN`  | All data            | Both sides                |
| `CROSS JOIN` | Cartesian product   | Every combination         |
| `SELF JOIN`  | Table joins itself  | Hierarchies               |
| `CTE`        | `WITH` clause       | Modular queries           |


